---1.基础配置	hibernate初识
	1-》window-》preferences-》java-》build path-》user libraries将所需的所有jar包新建user libraries目录添加进来，方便后期使用加，
	我们新建3个，一个hibernate-core，其中所有的jar包就是我们解压的hibernate项目下的lib目录下required文件夹里面的hibernate运行所必须的jar包。
	juint4单元测试junit-4.10.jar ，还有数据库的连接驱动jar文件。此处使用的是oracle数据库
	2-》去项目里面拷贝一个hibernate.cfg.xml文件，在cfg文件里面写好连接数据库所需的基础条件
	property标签
		connection.class
		connection.url
		connection.username
		connection.password
		dialect
		show_sql
		format_sql
		hbm2ddl.auto
	mapping标签
		resource属性定义需要加载某个hbm文件，注意这里的hbm文件前面的包名需要使用/来区分，例如：<mapping resource="com/jinan/www/entity/Students.hbm.xml"/>
	
	实体类：Students.java 
	实体类(对象-关系)映射文件：Students.hbm.xml
			Hiernate采用XML格式的文件来指定对象和关系数据之间的映射。Hibernate通过这个文件来生成各种sql语句。
			命名规则为 实体类名.hbm.xml  应该和实体类放在同一目录下。
	hibernate配置文件：hibernate.cfg.xml
	test类：test源文件夹下的StudentsTest.java文件

---2.hibernate进阶
		1.hibernate.cfg.xml常用配置
			show_sql
			format_sql
			hbm2ddl.auto可以帮助由java代码生成数据库脚本，进而生成具体的表结构。create(如果有那么删除)|update|create-drop(先创建再删除)|validate(如果现有的表结构和原来的表结构不同，那么就不会继续执行)
			default_schema默认的数据库
			dialect 数据库方言
			
		2.session简介
		 hibernate不建议直接使用connection操作数据库，而是通过session操作数据库，可以理解为操作数据的对象。
		 session与connection是多对一的关系。每个session都有一个与之对应的connection，一个connection不同时刻可供多个session使用
		 save(),update(),delete(),createQuery()....
		 
		3.transaction简介
		
		hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。所以用session保存对象时，如果不开启事务，并且手工提交事务，对象并不会真正保存在数据库中。
		如果你想让hibernate像JDBC那么自动提交事务，必须调用session对象的dowork()方法，获得JDBC的connection后，设置其为自动提交模式。(通常不推荐这样做)
		（这里在StudentsTest2.java中测验了。但是很遗憾没有通过，不知道是不是hibernate版本的问题还是其他的，貌似不是很重要，暂且跳过）
		
		
		4.session详解
		获得session的方式：
			openSession()
			getCurrentSession();
		如果使用getCurrentSession需要在hibernate.cfg.xml文件中配置：
			如果是本地事务（JDBC事务）
				<property name="hibernate.current_session_context_class">thread</property>		
			如果是全局事务（jta事务）
				<property name="hibernate.current_session_context_class">jta</property>
		
		SessionTest.java
		
		区别：1，getCurrentSession在事务提交或者回滚后会自动关闭，而openSession需要手动关闭，如果使用openSession没有手动关闭，多次之后会导致连接池溢出。
		2，openSession每次创建新的session对象，getCurrentSession使用现有的session对象。
		
		SessionTest.java
		
		5.hbm配置文件常用配置（还需要总结）
		<hibernate-mapping></hibernate-mapping>常用属性
		
		
---3.单表操作
		1.单一主键
			主键的生成策略：assigned 由java应用程序负责生成（手工赋值）
						native 由底层数据库自动生成标识符，如果是mysql就是increment，如果是oracle就是sequence，等等。
		2.基本类型
			参考img图片。
		3.对象类型
			使用hibernate读取、写入一个blob类型的数据。
			testWriteBlob();testReadBlob();
		4.组件属性
			实体类中的某个属性属于用户自定义的类的对象
			Teacher.java
			 Address.java
			  Teacher.hbm.xml 
			  TestComponent.java
		5.单表操作crud实例
			save()
			delete()
			update()
			get/load(查询单个记录)
				1，get方法会在调用之后立即向数据库发出sql语句，返回持久化对象。load方法会在调用之后返回一个代理对象，该代理对象只保存了
					实体对象的id，知道使用对象的非主键属性时才会发出sql语句。
				2，查询数据库中不存在的数据时，get方法返回null
					load方法抛出异常org.hibernate.ObjectNotFoundException



---3.一对多映射
		
		问题：待测。就是不管是单向的多对一，还是一对多。我们始终操作的都是对学生的crud，班级的crud并没有测试。
		
		分3个部分：单向的一对多关联	单向的多对一关联  inverse和cascade属性
		
		首先是单向的一对多关联。
		
			1，sql建表语句 student.sql，注意看在多的一方student表中有个字段是gid，作为外键去关联grade表中的id，使用关联外键来表示自己是多的一方。
			2，新建实体类，Grade.java,Student.java,其中班级类是一的一方，学生类是多的一方，在一的一方中使用set集合的属性把多的一方加入进来。
				private Set<Student> students=new HashSet<>();
			重点记忆的地方：
			3，student.hbm.xml正常配置。然后在一的一方grade.hbm.xml配置文件中需要进行特殊的配置。
				<!-- 配置单向的一对多关联关系 -->
					<set name="students" table="student">
					<!-- 指定关联的外键列 -->
					<key column="gid"></key>
					<one-to-many class="com.jinan.www.entity.Student"/>
				</set>
			4，然后在hibernate的配置文件中使用mapping标签，把实体类的映射文件加入进来。
				<mapping resource="com/jinan/www/entity/Grade.hbm.xml"/>
				<mapping resource="com/jinan/www/entity/Student.hbm.xml"/>
			5.最后编写测试类
				Test.java 测试多的一方学生的增删改查操作。
		
		其次是单向的多对一的关联。
		
			1，sql建表语句student1.sql	，同之前建立的一样。
			2，新建实体类，Grade1.java，Student1.java，其中班级类是一的一方，学生类是多的一方，既然是单向的多对一的关联，那么我们
			并没有在一的一方加入student1的set集合，但是却在Student1中加入了Grade1属性。同时增加了getter、setter方法。构造方法。
			
			private Grade1 grade1;
			
			3，grade1.hbm。xml普通配置，不需要配置set属性，然后Student1.hmb。xml需要配置many2one标签。
			
			<!-- 配置多对一关联关系 -->
			<many-to-one name="grade1" class="com.jinan.www.entity.Grade1" column="gid"></many-to-one>	
		
			4，然后在hibernate的配置文件中使用mapping标签，把实体类的映射文件加入进来。
			<mapping resource="com/jinan/www/entity/Grade1.hbm.xml"/>
			<mapping resource="com/jinan/www/entity/Student1.hbm.xml"/>	
			5，测试。test1.java
			
		inverse和cascade属性，详见img
			inverse属性用来设置关联关系由谁来控制。在一对多的关联关系中，默认是由一方来维护的，通过设置一方的inverser属性为true，
			这样可以将关联关系的维护交由多方来维护，这样可以避免生成更多的维护的sql语句，能够提升性能。
			cascade属性用来进行级联操作，当属性不为none时，hibernate会自动持久化关联的操作对象。也就是只需要session.save(grade),
			那么grade关联的student1 ，student2，。。。也都会保存到数据库中，增删改查操作都会持久化。
			取值：
					all	对所有操作进行级联操作
					save-update	执行保存和更新操作时进行级联操作
					delete 	执行删除操作时进行级联操作
					none	对所有操作不进行级联操作
					
		如果同时配置了单向的一对多，多对一，那么我们就完成了双向一对多或者叫双向多对一。那么我们既可以方便的由学生查找到对应的班级的信息，
		也可以方便的由班级查找到其所包含学生的信息
			
---4.多对多映射
		1,基本的hibernate配置，拷贝hibernate的jar包，lib-required文件夹下的必须得jar文件。拷贝cfg文件和hbm文件，方便后期修改。
		2，创建持久化类，多对多的关联关系，那么分别需要在两个实体类中都添加对方的set集合属性。创建持久化对象映射文件。通过set标签，来配置
		多对多的关联关系。多对多的关联关系需要用第三张关联关系表来体现。并且关联关系表中的字段都是外键去关联每张表里面的主键。参考sql脚本。
			<set name="projects" table="proemp" inverse="true"><!-- 关联关系的维护由project方来维护 -->
				<key column="rempid"></key><!-- 关联的外键，当前的这个映射文件对应的关联关系表中对应的外键id -->
				<many-to-many class="com.jinan.www.entity.Project" column="rproid"></many-to-many><!-- 集合属性中的持久化类，持久化类所对应的关联外键 -->
			</set>	
			把映射文件的物理路径加入到cfg文件中。
			<mapping resource="com/jinan/www/entity/employee.hbm.xml"/>
		3，编写测试类。
			cfg文件，
			HibernateUtil.java，
			Employee.java,
			Project.java,
			employee.hbm.xml,
			project.hbm.xml,
			Test.java		

---6.缓存策略
	1，hibernate一级缓存又称为Session缓存，会话级缓存，通过Session从数据库查询实体时会把实体在内存中存储起来，下一次查询同一实体时不再从数据库获取，而从内存中获取，这就是缓存。
	一级缓存和session的生命周期是一样的，session销毁，一级缓存就销毁了。一级缓存的数据可适用范围在当前会话之内。
		一级缓存无法取消，用两个方法管理
		evict() :用于将某个对象从Session的一级缓存中清除，清除缓存中指定的对象。
		clear():用于将一级缓存中的所有对象全部清除。
		
		Query query = session.createQuery("from Employee");
		List<Employee> list = query.list();
		for(Employee employee:list){
			syso(employee.getName());
		}
		
		Iterator it = query.iterate();这个方法在这个版本当中已经废弃了。
		while(it.hasNext()){
			syso(it.next().getName());
			}
		当使用query对象查询所有的数据时，query对象的list方法和iterator()方法虽然发出的sql语句不一样，但是list没有使用一级缓存，而iterater会使用到。
		
	2,有些常用的数据,在一个session中缓存后,我们希望在其他session中能够直接使用,而不用再次缓存怎么办.
		使用更高级别的二级缓存,每个session共用的缓存。
		
		二级缓存的配置步骤：
			1，添加二级缓存对应的jar包 \hibernate-release-5.3.5.Final\lib\optional\ehcache文件夹下的jar包，
			2，将二级缓存的配置文件放到src目录下 ehcache.xml 直接在工程里面搜索此文件
	 		3，添加二级缓存的属性配置文件到cfg文件中hibernate.cfg.xml
			4，在需要被缓存的表所对应的映射文件中添加<cache/>标签。animals.hbm.xml
			<cache usage="read-only" include="all" region="defaultCache"/><!-- 亲测，如果不放一开始，还会报错 -->
				<cache/>标签的详细介绍：
					usage：指定缓存策略，可选的策略包括：transactional,read-write,nonstrict-read-write,read-only只读事务模式.
					include:all ,non-lazy（并不会缓存当前对象的进行延迟加载的属性）。
					region：值是自己定义的。就是使用的是ehcache.xml配置文件中使用的那种缓存策略。例如：
						<defaultCache
					        maxElementsInMemory="10000" 表示缓存中允许创建的最大对象数
					        eternal="false"				表示缓存中对象是否是永久的。
					        timeToIdleSeconds="120"		表示缓存数据钝化时间（即对象在它过期前的空闲时间）
					        timeToLiveSeconds="120"		表示缓存数据生存时间（即对象在它过期前的生存时间）
					        overflowToDisk="true"		表示溢出之后是否存储在硬盘上
					        />
					        
			Test.java-->testCache2()方法使用了二级缓存
						
	3，总结：1，hibernate的缓存能提高检索效率
			2，hibernate的缓存分为一级缓存和二级缓存，一级缓存是会话级缓存，二级缓存是应用级缓存。
			3，hibernate的混存在提高检索的同时，也会增加服务器的消耗，所以要注意缓存的使用策略.	
		
---7.数据库连接池
	
	摘抄：https://blog.csdn.net/super712/article/details/52823192
	
	三种连接都是以连接MySQl为例。 
		<!-- JDBC驱动程序 --> 
		< property name="connection.driver_class">org.gjt.mm.mysql.Driver</property> <property name="connection.url">jdbc:mysql://localhost:3306/struts?useUnicode=true&characterEncoding=GBK</property> <!-- 数据库用户名 -->
		< property name="connection.username">root</property> <!-- 数据库密码 --> 
		< property name="connection.password">8888</property> 
		上面的一段配置，在c3p0和dbcp中，都是必需的，因为hibernate会根据上述的配置来生成connections，再交给c3p0或dbcp管理.但是，proxool则不能，虽然说服文档上说proxool也可以和hibernate结合,但我按照官方文档上的说明怎么配也出错，而且，到了sun和hibernat有的官方网站上问了几天，都没有一个人回复。后来我只能让proxool自身来生成连接，这在下面再讲。
		1 C3P0 
		只需在hibernate.cfg.xml中加入 
		<property name="c3p0.min_size">5</property> 
		< property name="c3p0.max_size">30</property> 
		< property name="c3p0.time_out">1800</property> 
		< property name="c3p0.max_statement">50</property> 
		还有在classespath中加入c3p0-0.8.4.5.jar 
		2 dbcp 
		在hibernate.cfg.xml中加入 
		<property name="dbcp.maxActive">100</property> 
		< property name="dbcp.whenExhaustedAction">1</property> 
		< property name="dbcp.maxWait">60000</property> 
		< property name="dbcp.maxIdle">10</property> 
		< property name="dbcp.ps.maxActive">100</property> 
		< property name="dbcp.ps.whenExhaustedAction">1</property> 
		< property name="dbcp.ps.maxWait">60000</property> 
		< property name="dbcp.ps.maxIdle">10</property> 
		还有在classespath中加入commons-pool-1.2.jar 和commons-dbcp-1.2.1.jar. 
		3 proxool 
		在hibernate.cfg.xml中加入 
		<property name="proxool.pool_alias">pool1</property> 
		< property name="proxool.xml">ProxoolConf.xml</property> 
		< property name="connection.provider_class">net.sf.hibernate.connection.ProxoolConnectionProvider</property>
		然后，在和hibernate.cfg.xml同一个目录下，加一个ProxoolConf.xml文件，内容为 
		<?xml version="1.0" encoding="utf-8"?> 
		< !-- the proxool configuration can be embedded within your own application's. 
		Anything outside the "proxool" tag is ignored. --> 
		< something-else-entirely> 
		< proxool> 
		< alias>pool1</alias> 
		< !--proxool只能管理由自己产生的连接--> 
		< driver-url>jdbc:mysql://localhost:3306/struts?useUnicode=true&characterEncoding=GBK</driver-url>
		< driver-class>org.gjt.mm.mysql.Driver</driver-class> 
		< driver-properties> 
		< property name="user" value="root"/> 
		< property name="password" value="8888"/> 
		< /driver-properties> 
		< !-- proxool自动侦察各个连接状态的时间间隔(毫秒),侦察到空闲的连接就马上回收,超时的销毁--> 
		< house-keeping-sleep-time>90000</house-keeping-sleep-time> 
		< !-- 指因未有空闲连接可以分配而在队列中等候的最大请求数,超过这个请求数的用户连接就不会被接受--> 
		< maximum-new-connections>20</maximum-new-connections> 
		< !-- 最少保持的空闲连接数--> 
		< prototype-count>5</prototype-count> 
		< !-- 允许最大连接数,超过了这个连接，再有请求时，就排在队列中等候，最大的等待请求数由maximum-new-connections决定--> 
		< maximum-connection-count>100</maximum-connection-count> 
		< !-- 最小连接数--> 
		< minimum-connection-count>10</minimum-connection-count> 
		< /proxool> 
		< /something-else-entirely> 
		并在classespath中加入proxool-0.8.3.jar 
		结论： 
		由于在hibernate3.0中，已经不再支持dbcp了，hibernate的作者在hibernate.org中，明确指出在实践中发现dbcp有BUG,在某些种情会产生很多空连接不能释放，所以抛弃了对dbcp的支持。我不知是否在dbcp最新版本中解决了这个问题，我以前在一个访问量不大的项目中用过dbcp，运行了一年多都没出现问题。不过在网上的确也有不少网友指出dbcp在大型的应用中会出现不稳定的情况。所以在真相未经证实的情况下，我觉得对dbcp持慎重的态度。
		至于c3p0，有评论说它的算法不是最优的，而且，我在matrix中，见到有网友做了一个实验，在同一项目中分别用了几个常用的连接池，然后测试其性能，发现c3p0占用资源比较大，效率也不高。
		所以，基于上述原因，我才花两晚的时间去研究proxool的配置，proxool不少行家推荐使用，而且暂时来说，是负面评价是最少的一个。在三星中也有项目是用proxool的。
		
		---------------------
---8.逆向工程，正向工程（此处是针对eclipse中的，eclipse版本oxygen3.a，hibernate5.3.5，

	参考帖子：https://blog.csdn.net/wangpeng047/article/details/6877720#commentBox
	
	逆向工程：从数据库生成hibernate实体类的方法叫做逆向工程。先有表。
	
	1，首先，要在eclipse中使用自带的数据库管理器连通数据库。show view-Data Source Explorer。
	配置完成后出现数据库资源管理器，说明数据库配置成功。
	2.生成hibernate实体类。show view-hibernate configurations-add configuration
	project选择工程，database connections选择第一步建立的连接。properties files和configuration file都可以新建。但是亲测后
	发现properties文件虽然自动生成，但是内容为空，而configuration文件无法自动生成，所以configuration文件使用从其他工程拷贝过来的即可。
	然后在common选项标签中设置utf-8字符集。这样hibernate configuration就生成了一个配置信息。选择hibernate code generation按钮，
	就是上面的运行按钮里面含有hibernate图标的运行按钮，选择hibernate code genaration configurations 然后在hibernate code generation上面new，
	在弹出来的窗口中，console configuration选择我们上面建立的配置信息，然后选择输出路径，勾选reverse engineer from jdbc connection
	起个package名，新建reveng.xml，新建的过程中console configuration也是选择我们上面建立的配置信息，点击refresh按钮等待刷新出来所有的数据库，include里面，然后回hibernate
	code generation configurations 界面后在exporters选项标签中勾选domain code 和hibernate xml mappings两个选项，点击run即可。
	
	正向工程：通过hibernate实体类映射文件和实体类来生成数据库表的过程。先有类，通过类生成数据表。
	
	1，配置好hibernate的环境后，编写实体类和实体类配置文件（实体类自己写，然后利用插件辅助生成hbm映射文件），通过配置hibernate的配置文件hbm2ddl 值create来创建数据库表。
	
	通常我们在第一次使用的时候可以单独写一个类运行一下，来生成数据库表后再改成update方便后期操作。
	

---5.注解
---9.延迟加载。
---10.主键的生成策略
                generator标签用来设定主键生成策略，hibernate内置的几种主键生成策略
                1.increment 适用于代理主键。由Hibernate自动以递增的方式生成主键，每次增量为1 ，会执行两个sql语句，先从表中查找出最大的id，然后加一，插入当前数据
                2.identity  适用于代理主键。由底层数据库生成主键，依赖数据库的主键自增功能
                3.sequence  适用于代理主键。由底层数据库的序列来生成主键，前提是数据库支持序列。（mysql不支持，oracle支持）
                4.hilo      适用于代理主键。Hibernate根据hilo算法来自己生成主键。
                5.native    适用于代理主键。根据底层数据库对自动生成主键的支持能力选择 identity|sequence|hilo
                6.uuid      适用于代理主键。采用UUID算法生成主键。
                7.assigned  适用于自然主键。由我们自己指定主键值。例如指定身份证号为主键值
---11.hql语句。是面向对象的查询语句。区分大小写，但是关键字不区分。
			select...   from...(必需的。)  where...   group by...   having...   order by....
			1，HQL是面向对象的查询语言，对java类与属性大小写敏感。
			2，HQL对关键字不区分大小写。
			
		1--Query接口简介	 
			1，Query接口定义有执行查询的方法。
			2，Query接口支持方法链编程风格，使得程序代码更加简洁。
			Query实例的创建
				1，Session的createQuery()方法创建query实例
				2，createQuery方法包含一个HQL语句参数，createQuery(hql)
			Query执行查询
			 	1，Query接口的list方法执行HQL查询
			 	2，list()方法返回结果数据类型为java.util.List，List集合中存放符合查询条件的持久化对象。
			 	
			Seller.java 
			Seller.hbm.xml配置文件
			hibernate.cfg.xml
			Test-testQuery()方法。
			 	
		2--查询对象-from子句
			1》from子句的介绍
			2》from子句中持久化类的引用
				1不需要引入持久化类的全限定名，直接引入类名 from Seller
				2auto-import （自动引入）缺省情况
			3》别名
				1为被查询的类指定别名
				2在hql语句其他部分通过别名引用该类
				3别名命名习惯 String hql ="from Seller s,Customer c";
		3--选择select子句
			1》以Object[]形式返回选择的属性
				testSelectClauseObjectArray()
			2》以List形式返回选择的属性
				testSelectClauseList()
			3》以map形式返回选择的属性
				testSelectClauseMap()
			4》以自定义类型返回选择的属性
				testSelectClauseSelf
			5》获取独特的结果-distinct关键字
				testDistinct()
				
		4--限制-where子句
			1》比较运算  ：=相当、 <>不等 、<、>、<=、>=、null值判断-is[not] null(允许我们使用相等不等来判断null)、、、
				String sql="from Commodity c where c.price>400";
				String sql="from Commodity c where c.description is null";
				String sql="from Commodity c where c.description = null";
				String sql="from Commodity c where c.description <> null";
			2》范围运算
				1.[not] in (列表)
				2.[not] between 值1 and 值2
				String sql="from Customer c where c.age in (20,40)";
				String sql="from Customer c where c.age not in (20,40)";
				String sql="from Customer c where c.age between 20 and 40";
				String sql="from Customer c where c.age not between 20 and 40";
			3》字符串模式匹配
				1.like关键字
				2.通配符  %（匹配多个）、 _（匹配单个）
				String sql= "from Customer c where c.name like '张_'";
				String sql= "from Customer c where c.address like '%北京%'";
			4》逻辑运算
				1.逻辑与and
				2.逻辑或or
				3.逻辑非not
				String sql= "from Customer c where c.price between 500 and 5000 and c.category like '%电脑%'";
				String sql= "from Customer c where c.price between 500 and 5000 or c.category like '%电脑%'";
				
			5》集合运算
				1.is [not] empty集合[不]为空，不包含任何元素
				2.member of 元素属于集合
				hibernate会转换为对应的运算
					empty --》 exists
					member of --》 in
					
					String hql = "from Order o where o.orderItems is empty";
					String hql = "from Order o where o.orderItems is not empty";
			6》在HQL中使用+-*/运算符
				1.HQL语句中也可以使用+-*/四则运算
				2.四则运算可以在where子句和select子句中使用
				String  sql= "from Commodity c where c.price*5>3000";
			
			7》查询单个对象（uniqueResult方法）
				1.Query接口的uniqueResult方法
				2.where子句的条件的设置要适当，必须要保证只查询到一条数据。如果是多条数据的话就会报错。
				String sql = "from Customer c where c.name='张三'";
				Query query= session.createQuery(sql);
				
				Customer c =(Customer)query.uniqueResult();
		5---order by 子句
				1.升序排序 asc 
				2.降序排序 desc
				String sql ="from Customer c  order by c.price asc,c.name desc,c.description asc [";
			
			 	
			 	
			 	
	 第一种方式  	HQL语言是面向对象的
            Query query=session.createQuery("from User");



			Query对象：   封装HQL语句的对象。
			
			        返回一个对象的方法 query.uniqueResult();
			
			        分页相关
			        query.setFirstResult(index):从第几个取
			        query.setMaxResults(count):指定取几行记录
            第二种方式
            Criteria c=session.createCriteria(User.class);
            List<User> l=c.list();

            第三种方式，使用原生sql语句进行查询
            SQLQuery query=session.createSQLQuery("select * from user");
            List l=query.list();
            
---12.hibernate处理事务并发问题
			在Hibernate中设置事务的隔离级别。
			<property name="hibernate.connection.isolation">2</property>
			
			隔离级别代号。
			1：Read Uncommitted
			2: Read Committed
			4: Repeatable Read 
			8: Serializable
			
---13.锁的基本原理

		  为了避免各种并发问题，以保证数据的完整性和一致性，数据库系统采用锁来实现事务的隔离性。 
	
	    锁的类型
	    -共享锁：用于读数据操作。允许其他事务同时读取资源，但不允许其它事务更新。
	    -独占锁：用于修改数据的场合。它锁定的资源，其他事务不能读取也不能修改。 
	
	    锁的基本原理如下
	        -当一个事务访问某种数据库资源时，如果执行select语句，必须先获得共享锁。
	        如果执行update、insert、delete语句，必须先获得独占锁。
	
	        -当第二个事务也要访问相同的资源时，如果执行select语句，也必须获得共享锁。
	        如果执行update、insert、delete语句，也必须先获得独占锁。
	        此时根据锁的类型。来决定第二个事务是应该等待第一个事务完成，还是可以立即获得锁。
	
	    许多数据库系统都有自动管理锁的功能，能够根据事务执行的sql语句，自动为资源加上适当的锁。